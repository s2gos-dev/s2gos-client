#  Copyright (c) 2025 by ESA DTE-S2GOS team and contributors
#  Permissions are hereby granted under the terms of the Apache 2.0 License:
#  https://opensource.org/license/apache-2-0.

# DONE: identify and collect $ref classes in to_py_type()
# DONE: output to s2gos/client/api.py
# DONE: add imports from s2gos.models
# DONE: clarify callbacks and handle callbacks --> not needed for now
# DONE: implement real call_api() in s2gos/client/service.py, import it
# DONE: use "ruff format" at the end
# TODO: complete generating docstrings: handle parameter default values
# TODO: complete generating docstrings: handle requestBody
# TODO: complete generating docstrings: handle responses
# TODO: support multiple success codes, e.g., 200, 201, etc
# TODO: support multiple error codes, e.g., 401, 500, etc

import re
import subprocess
from pathlib import Path
from typing import Any, Literal

import datetime

from s2gos_gen.common import S2GOS_PATH, OPEN_API_PATH
from s2gos_gen.openapi import load_openapi_schema, OASchema, OAContent, OAMethod


CLIENT_PATH = S2GOS_PATH / "client" / "api" / "api.py"


def main():
    schema = load_openapi_schema(OPEN_API_PATH)
    models: set[str] = set()
    code = generate_api_code(schema, models)
    with CLIENT_PATH.open("wt") as stream:
        stream.write(f"# generated by {Path(__file__).name}:\n")
        stream.write(f"#   filename:  {CLIENT_PATH.name}:\n")
        stream.write(f"#   timestamp: {datetime.datetime.now().isoformat()}\n")
        stream.write("\n")
        stream.write("from typing import Any, Optional\n")
        stream.write("\n")
        stream.write(
            "from s2gos.common.models import " + ", ".join(sorted(models)) + "\n"
        )
        stream.write("from .service import Service")
        stream.write("\n")
        stream.write(code)

    print(f"Generated {CLIENT_PATH}")
    subprocess.run(["ruff", "format", str(CLIENT_PATH)])


def generate_api_code(schema: OASchema, models: set[str]) -> str:
    functions: list[str] = []
    for path, endpoint in schema.paths.items():
        for method_name, method in endpoint.items():
            function_code = generate_function_code(path, method_name, method, models)
            functions.append(function_code)
    return "\n\n".join(functions)


def generate_function_code(
    path: str,
    method_name: Literal["get", "post", "put", "delete"],
    method: OAMethod,
    models: set[str],
) -> str:
    param_defs: list[str] = []
    param_kwargs: list[str] = []
    for parameter in method.parameters:
        param_name = camel_to_snake(parameter.name)
        param_type = "Any"
        param_default: str | None = None
        if parameter.schema_:
            param_type = to_py_type(
                parameter.schema_,
                f"{method.operationId}.{parameter.name}",
                models,
            )
            default_value = parameter.schema_.get("default", ...)
            if default_value is not ...:
                param_default = repr(default_value)
        if param_default is not None:
            param_defs.append(f"{param_name}: {param_type} = {param_default}")
        else:
            param_defs.append(f"{param_name}: {param_type}")
        param_kwargs.append(f"{parameter.name!r}: {param_name}")
    param_defs.append("_service: Optional[Service] = None")
    param_list = ", ".join(param_defs)
    param_dict = "{" + ", ".join(param_kwargs) + "}"
    return_type = "Any"
    ok_response = method.responses.get("200")
    if ok_response and ok_response.content:
        json_content: OAContent | None = ok_response.content.get("application/json")
        if json_content and json_content.schema_:
            return_type = to_py_type(json_content.schema_, path, models)

    function_doc = generate_function_doc(method)

    return (
        f"def {camel_to_snake(method.operationId)}({param_list}) -> {return_type}:\n"
        f"{function_doc}"
        "    return (_service or Service.default()).call("
        f"path={path!r}, "
        f"method={method_name!r}, "
        f"params={param_dict}, "
        f"return_type={return_type}"
        f")\n"
    )


def generate_function_doc(method: OAMethod) -> str:
    doc_lines = method.description.split("\n") if method.description else []

    if method.parameters:
        if doc_lines and doc_lines[-1] != "":
            doc_lines.append("")
        doc_lines.append("Params:")
        for parameter in method.parameters:
            param_name = camel_to_snake(parameter.name)
            if parameter.description:
                param_desc_lines = parameter.description.split("\n")
                doc_lines.append(f"  {param_name}: {param_desc_lines[0]}")
                doc_lines.extend([f"    {line}" for line in param_desc_lines[1:]])
            else:
                doc_lines.append(f"  {param_name}:")
    # TODO: split long lines that exceed 80 characters
    if method.requestBody:
        # TODO: generate doc for method.requestBody, document extra "payload" param
        pass
    if method.responses:
        # TODO: generate doc for method.responses, document "Returns:"
        pass
    doc_lines = [
        '"""',
        *doc_lines,
        '"""',
    ]
    doc_lines = [f"    {line}" for line in doc_lines]
    return "\n".join(doc_lines) + "\n"


_REF_PREFIX = "#/components/schemas/"

_PY_TYPES = {
    "null": "None",
    "boolean": "bool",
    "integer": "int",
    "number": "float",
    "string": "str",
    "array": "list[Any]",
    "object": "dict[str, Any]",
}


def to_py_type(
    schema: dict[str, Any], path: str, models: set[str], optional: bool = False
) -> str:
    # print(path, f"{schema!r}")
    ref_uri: str | None = schema.get("$ref")
    if ref_uri:
        assert ref_uri.startswith(_REF_PREFIX)
        component_name = ref_uri[len(_REF_PREFIX) :]
        type_name = component_name[0].upper() + component_name[1:]
        models.add(type_name)
        return type_name

    one_of: list[dict] | None = schema.get("oneOf")
    if one_of:
        return to_py_union_type(
            [to_py_type(s, path + f".oneOf[{i}]", models) for i, s in enumerate(one_of)]
        )

    any_of: list[dict] | None = schema.get("anyOf")
    if any_of:
        return to_py_union_type(
            [to_py_type(s, path + f".anyOf[{i}]", models) for i, s in enumerate(any_of)]
        )

    all_of: list[dict] | None = schema.get("allOf")
    if all_of:
        for i, s in enumerate(all_of):
            if s.get("$ref"):
                return to_py_type(s, path + f".allOf[{i}]", models)
        for i, s in enumerate(all_of):
            if s.get("type"):
                return to_py_type(s, path + f".allOf[{i}]", models)
        print(f"warn: cannot convert {path}.allOf")

    enum_ = schema.get("enum")
    if enum_:
        return f"Literal[{', '.join(to_py_literal(v) for v in enum_)}]"

    const = schema.get("const", ...)
    if const is not ...:
        return f"Literal[{to_py_literal(const)}]"

    json_type = schema.get("type")
    if json_type == "array":
        items_schema = schema.get("items")
        item_type = to_py_type(items_schema, path + ".type", models)
        py_type = f"list[{item_type}]"
    elif isinstance(json_type, str):
        py_type = _PY_TYPES[json_type]
    elif isinstance(json_type, (list, tuple)):
        py_type = to_py_union_type([_PY_TYPES[t] for t in json_type])
    else:
        print(f"warn: cannot convert {path}")
        py_type = "Any"
    return to_py_union_type([py_type, "None"]) if optional else py_type


def camel_to_snake(name: str) -> str:
    """
    Convert a camelCase or PascalCase string to snake_case.
    Ensures that the output is also a valid identifier in Python, C, or Java.

    Args:
        name (str): A valid camelCase or PascalCase identifier.

    Returns:
        str: The converted snake_case identifier.
    """
    # Add underscore between lowercase-to-uppercase transitions
    name = re.sub(r"(?<=[a-z0-9])([A-Z])", r"_\1", name)
    # Add underscore between adjacent capitals and followed by lowercase (e.g., "HTTPServer" -> "http_server")
    name = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    # Convert to lowercase
    snake = name.lower()
    # If it starts with a digit, prepend an underscore to make it a valid identifier
    if snake and snake[0].isdigit():
        snake = "_" + snake
    return snake


def to_py_literal(value) -> str:
    return repr(value)


def to_py_union_type(py_types: list[str]) -> str:
    return " | ".join(py_types)


if __name__ == "__main__":
    main()
