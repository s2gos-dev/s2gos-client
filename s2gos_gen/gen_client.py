#  Copyright (c) 2025 by ESA DTE-S2GOS team and contributors
#  Permissions are hereby granted under the terms of the Apache 2.0 License:
#  https://opensource.org/license/apache-2-0.

import re
import subprocess
from pathlib import Path
from typing import Any, Literal

import datetime

from s2gos_gen.common import S2GOS_PATH, OPEN_API_PATH
from s2gos_gen.openapi import load_openapi_schema, OASchema, OAMethod


CLIENT_PATH = S2GOS_PATH / "client" / "api" / "client.py"

C_TAB = "    "
D_TAB = "  "


def main():
    schema = load_openapi_schema(OPEN_API_PATH)
    models: set[str] = set()
    code = generate_api_code(schema, models)
    model_list = ", ".join(sorted(models))
    with CLIENT_PATH.open("wt") as stream:
        stream.write(f"# generated by {Path(__file__).name}:\n")
        stream.write(f"#   filename:  {CLIENT_PATH.name}:\n")
        stream.write(f"#   timestamp: {datetime.datetime.now().isoformat()}\n")
        stream.write("\n")
        stream.write("from typing import Optional\n")
        stream.write("\n")
        stream.write(f"from s2gos.common.models import {model_list}\n")
        stream.write("from .service import DefaultService, Service")
        stream.write("\n")
        stream.write("class Client:\n")
        stream.write(f'{C_TAB}"""\n')
        stream.write(f"{C_TAB}The S2GOS Client API.\n")
        stream.write("\n")
        stream.write(f"{C_TAB}Args:\n")
        stream.write(f"{C_TAB}{D_TAB}service: Optional API service instance.\n")
        stream.write(
            f"{C_TAB}{D_TAB}kwargs: Configuration passed to `DefaultService` constructor.\n"
        )
        stream.write(f"{C_TAB}{D_TAB}{D_TAB}if `service` is not provided.\n")
        stream.write(f'{C_TAB}"""\n')
        stream.write("\n")
        stream.write(
            f"{C_TAB}def __init__(self, *, service: Optional[Service] = None, **kwargs):\n"
        )
        stream.write(
            f"{C_TAB}{C_TAB}self._service = DefaultService(**kwargs) if service is None else service\n"
        )
        stream.write("\n")
        stream.write(code)

    print(f"Generated {CLIENT_PATH}")
    subprocess.run(["ruff", "format", str(CLIENT_PATH)])
    subprocess.run(["ruff", "check", str(CLIENT_PATH)])


def generate_api_code(schema: OASchema, models: set[str]) -> str:
    functions: list[str] = []
    for path, endpoint in schema.paths.items():
        for method_name, method in endpoint.items():
            # noinspection PyTypeChecker
            function_code = generate_function_code(path, method_name, method, models)
            functions.append(function_code)
    return "\n\n".join(functions)


def generate_function_code(
    path: str,
    method_name: Literal["get", "post", "put", "delete"],
    method: OAMethod,
    models: set[str],
) -> str:
    param_args: list[str] = ["self"]
    param_kwargs: list[str] = []
    param_mappings: list[str] = []
    for parameter in method.parameters:
        param_name = camel_to_snake(parameter.name)
        param_type = "Any"
        param_default: str | None = None
        if parameter.schema_:
            param_type = to_py_type(
                parameter.schema_,
                f"{method.operationId}.{parameter.name}",
                models,
            )
            default_value = parameter.schema_.get("default", ...)
            if default_value is not ...:
                param_default = repr(default_value)
        if param_default is None:
            param_args.append(f"{param_name}: {param_type}")
        else:
            param_kwargs.append(f"{param_name}: {param_type} = {param_default}")
        param_mappings.append(f"{parameter.name!r}: {param_name}")

    request_type: str | None = None
    if method.requestBody:
        request_type = "Any"
        json_content = method.requestBody.content.get("application/json")
        if json_content and json_content.schema_:
            request_type = to_py_type(
                json_content.schema_, f"{method.operationId}.requestBody", models
            )
        if method.requestBody.required:
            param_args.append(f"request: {request_type}")
        else:
            param_kwargs.append(f"request: Optional[{request_type}] = None")

    param_list = ", ".join([*param_args, *param_kwargs])
    param_dict = "{" + ", ".join(param_mappings) + "}"

    return_types, error_types = parse_responses(method, models)

    if not return_types:
        return_types = {"200": "None"}

    function_doc = generate_function_doc(method)
    return_type_union = " | ".join(set(v[0] for v in return_types.values()))
    return_type_dict = (
        "{" + ", ".join([f"{k!r}: {v[0]}" for k, v in return_types.items()]) + "}"
    )
    error_type_dict = (
        "{" + ", ".join([f"{k!r}: {v[0]}" for k, v in error_types.items()]) + "}"
    )
    return (
        f"{C_TAB}def {camel_to_snake(method.operationId)}({param_list})"
        f" -> {return_type_union}:\n"
        f"{function_doc}"
        f"{C_TAB}{C_TAB}return self._service.call("
        f"path={path!r}, "
        f"method={method_name!r}, "
        f"params={param_dict}, "
        f"request={'request' if request_type else 'None'}, "
        f"return_types={return_type_dict}, "
        f"error_types={error_type_dict}"
        f")\n"
    )


def generate_function_doc(method: OAMethod) -> str:
    doc_lines = method.description.split("\n") if method.description else []

    if method.parameters:
        if doc_lines and doc_lines[-1] != "":
            doc_lines.append("")
        doc_lines.append("Params:")
        for parameter in method.parameters:
            param_name = camel_to_snake(parameter.name)
            if parameter.description:
                param_desc_lines = parameter.description.split("\n")
                doc_lines.append(f"{D_TAB}{param_name}: {param_desc_lines[0]}")
                doc_lines.extend(
                    [f"{2 * D_TAB}{line}" for line in param_desc_lines[1:]]
                )
            else:
                doc_lines.append(f"{D_TAB}{param_name}:")

    # TODO: split long lines that exceed 80 characters

    if method.requestBody:
        json_content = method.requestBody.content.get("application/json")
        if json_content:
            if method.requestBody.description:
                param_desc_lines = method.requestBody.description.split("\n")
                doc_lines.append(f"{D_TAB}request: {param_desc_lines[0]}")
                doc_lines.extend(
                    [f"{D_TAB}{D_TAB}{line}" for line in param_desc_lines[1:]]
                )
            else:
                doc_lines.append("  request:")

    return_types, error_types = parse_responses(method, set())

    def append_responses(
        resp_title: str, resp_types: dict[str, tuple[str, list[str]]], lines: list[str]
    ):
        lines.append("")
        lines.append(f"{resp_title}:")
        for resp_code, (resp_type, desc_lines) in resp_types.items():
            if desc_lines:
                lines.append(f"{D_TAB}{resp_type}: {desc_lines[0]}")
                for desc_line in desc_lines[1:]:
                    lines.append(f"{D_TAB}{D_TAB}{desc_line}")
            else:
                lines.append(f"{D_TAB}{resp_type}:")

    if return_types:
        append_responses("Returns", return_types, doc_lines)

    if error_types:
        append_responses("Raises", error_types, doc_lines)

    doc_lines = [
        '"""',
        *doc_lines,
        '"""',
    ]
    doc_lines = [f"{2 * C_TAB}{line}" for line in doc_lines]
    return "\n".join(doc_lines) + "\n"


def parse_responses(
    method: OAMethod,
    models: set[str],
) -> tuple[dict[str, tuple[str, list[str]]], dict[str, tuple[str, list[str]]]]:
    return_types: dict[str, tuple[str, list[str]]] = {}
    error_types: dict[str, tuple[str, list[str]]] = {}
    if method.responses:
        for key, response in method.responses.items():
            status_code = int(key)
            description = response.description
            desc_lines = description.split("\n") if description else []
            if response.content:
                json_content = response.content.get("application/json")
                if json_content and json_content.schema_:
                    response_type = to_py_type(
                        json_content.schema_, "responses", models
                    )
                    if 200 <= status_code < 300:
                        return_types[key] = response_type, desc_lines
                    else:
                        error_types[key] = response_type, desc_lines
    return return_types, error_types


_REF_PREFIX = "#/components/schemas/"

_PY_TYPES = {
    "null": "None",
    "boolean": "bool",
    "integer": "int",
    "number": "float",
    "string": "str",
    "array": "list[Any]",
    "object": "dict[str, Any]",
}


def to_py_type(
    schema: dict[str, Any], path: str, models: set[str], optional: bool = False
) -> str:
    # print(path, f"{schema!r}")
    ref_uri: str | None = schema.get("$ref")
    if ref_uri:
        assert ref_uri.startswith(_REF_PREFIX)
        component_name = ref_uri[len(_REF_PREFIX) :]
        type_name = component_name[0].upper() + component_name[1:]
        models.add(type_name)
        return type_name

    one_of: list[dict] | None = schema.get("oneOf")
    if one_of:
        return to_py_union_type(
            [to_py_type(s, path + f".oneOf[{i}]", models) for i, s in enumerate(one_of)]
        )

    any_of: list[dict] | None = schema.get("anyOf")
    if any_of:
        return to_py_union_type(
            [to_py_type(s, path + f".anyOf[{i}]", models) for i, s in enumerate(any_of)]
        )

    all_of: list[dict] | None = schema.get("allOf")
    if all_of:
        for i, s in enumerate(all_of):
            if s.get("$ref"):
                return to_py_type(s, path + f".allOf[{i}]", models)
        for i, s in enumerate(all_of):
            if s.get("type"):
                return to_py_type(s, path + f".allOf[{i}]", models)
        print(f"warn: cannot convert {path}.allOf")

    enum_ = schema.get("enum")
    if enum_:
        return f"Literal[{', '.join(to_py_literal(v) for v in enum_)}]"

    const = schema.get("const", ...)
    if const is not ...:
        return f"Literal[{to_py_literal(const)}]"

    json_type = schema.get("type")
    if json_type == "array":
        items_schema = schema.get("items")
        item_type = to_py_type(items_schema, path + ".type", models)
        py_type = f"list[{item_type}]"
    elif isinstance(json_type, str):
        py_type = _PY_TYPES[json_type]
    elif isinstance(json_type, (list, tuple)):
        py_type = to_py_union_type([_PY_TYPES[t] for t in json_type])
    else:
        print(f"warn: cannot convert {path}")
        py_type = "Any"
    return to_py_union_type([py_type, "None"]) if optional else py_type


def camel_to_snake(name: str) -> str:
    """
    Convert a camelCase or PascalCase string to snake_case.
    Ensures that the output is also a valid identifier in Python, C, or Java.

    Args:
        name (str): A valid camelCase or PascalCase identifier.

    Returns:
        str: The converted snake_case identifier.
    """
    # Add underscore between lowercase-to-uppercase transitions
    name = re.sub(r"(?<=[a-z0-9])([A-Z])", r"_\1", name)
    # Add underscore between adjacent capitals and followed by lowercase (e.g., "HTTPServer" -> "http_server")
    name = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    # Convert to lowercase
    snake = name.lower()
    # If it starts with a digit, prepend an underscore to make it a valid identifier
    if snake and snake[0].isdigit():
        snake = "_" + snake
    return snake


def to_py_literal(value) -> str:
    return repr(value)


def to_py_union_type(py_types: list[str]) -> str:
    return " | ".join(py_types)


if __name__ == "__main__":
    main()
